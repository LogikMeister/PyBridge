import{createRequire as t}from"node:module";import{fileURLToPath as i}from"node:url";import e from"node:path";import n from"node:process";"function"==typeof SuppressedError&&SuppressedError;const r=i(import.meta.url),o=e.dirname(r),s=t(import.meta.url),a=t=>e.resolve(o,t);let l;try{const t=a("../../dll");n.env.PATH=t+";"+n.env.PATH,l=s(a("../../build/Release/pybridge"))}catch(t){throw new Error("[Error]: Failed to load pybridge addon. Please check if pythonXX.dll exists in the environment variable PATH.")}const c=(h=(t,i,...e)=>!1===i[t],d="Python interpreter has not been initialized",function(t){return function(i,e){const n=String(e.name);return function(...e){if(h(t,this,...e))return i.call(this,...e);throw new Error(`${n}: ${d}, arg: ${t}`)}}});var h,d;const u=new((()=>{var t;let i,e=[];return t=class{constructor(){this.isInitialized=(function(t,i,e){for(var n=arguments.length>2,r=0;r<i.length;r++)e=n?i[r].call(t,e):i[r].call(t)}(this,e),!1)}initialize(t,i,e){this.pythonHome=t,this.pythonPath=i;try{l.initializePython(this.pythonHome,this.pythonPath,e);if(l.isInitialized())return this.isInitialized=!0,this.isInitialized;throw new Error}catch(i){throw this.isInitialized=!1,console.error("[Error]:",i.message),new Error(`Failed to initialize Python interpreter at ${t}.`)}}finalize(){this.isInitialized&&l.isInitialized()&&l.finalizePython(),this.isInitialized=!1}call(t,i,e){if(!this.isInitialized)throw new Error("Python interpreter has not been initialized.");return l.callPythonFunctionSync(t,i,e)}callAsync(t,i,e){if(!this.isInitialized)throw new Error("Python interpreter has not been initialized.");return l.callPythonFunctionAsync(t,i,e)}definePyFunction(t,i){const e=this;return function(n,r){return function(n){return e.callAsync(t,i,n)}}}},i=[c("isInitialized")],function(t,i,e,n,r,o){function s(t){if(void 0!==t&&"function"!=typeof t)throw new TypeError("Function expected");return t}for(var a,l=n.kind,c="getter"===l?"get":"setter"===l?"set":"value",h=!i&&t?n.static?t:t.prototype:null,d=i||(h?Object.getOwnPropertyDescriptor(h,n.name):{}),u=!1,f=e.length-1;f>=0;f--){var p={};for(var y in n)p[y]="access"===y?{}:n[y];for(var y in n.access)p.access[y]=n.access[y];p.addInitializer=function(t){if(u)throw new TypeError("Cannot add initializers after decoration has completed");o.push(s(t||null))};var m=(0,e[f])("accessor"===l?{get:d.get,set:d.set}:d[c],p);if("accessor"===l){if(void 0===m)continue;if(null===m||"object"!=typeof m)throw new TypeError("Object expected");(a=s(m.get))&&(d.get=a),(a=s(m.set))&&(d.set=a),(a=s(m.init))&&r.unshift(a)}else(a=s(m))&&("field"===l?r.unshift(a):d[c]=a)}h&&Object.defineProperty(h,n.name,d),u=!0}(t,null,i,{kind:"method",name:"initialize",static:!1,private:!1,access:{has:t=>"initialize"in t,get:t=>t.initialize}},null,e),t})());export{u as interpreter};
